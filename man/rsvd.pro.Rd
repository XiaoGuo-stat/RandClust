% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rsvd.pro.R
\name{rsvd.pro}
\alias{rsvd.pro}
\title{Compute randomized SVD of a matrix using random projection}
\usage{
rsvd.pro(A, rank, p = 10, q = 2, dist = "normal", approA = FALSE, nthread = 1)
}
\arguments{
\item{A}{Input data matrix of class "\code{dgCMatrix}". Not necessarily be the adjacency matrix of a network.}

\item{rank}{The target rank of the low-rank decomposition.}

\item{p}{The oversampling parameter. It need to be a positive integer number. Default value is 10.}

\item{q}{The power parameter. It need to be a positive integer number. Default value is 2.}

\item{dist}{The distribution of the entry of the random test matrix. Can be \code{"normal"} (standard normal distribution),
\code{"unif"} (uniform distribution from -1 to 1), or \code{"rademacher"} (randemacher distribution). Default
is \code{"normal"}.}

\item{approA}{A logical variable indicating whether the approximated \code{A} is returned. Default is \code{FALSE}.}

\item{nthread}{Maximum number of threads for specific computations which could be implemented in parallel. Default is 1.}
}
\value{
\item{u}{The randomized left \code{rank+p} singular vectors.} \item{v}{The randomized right \code{rank+p} singular vectors.}
        \item{d}{The \code{rank+p} singular values.} \item{approA}{The approximated data matrix obtained by {\eqn{udv}'} if requested.}
}
\description{
Compute the randomized SVD of a matrix by random projection. The randomized
singular vectors and singular values are computed. Can deal with very large
data matrix.
}
\details{
This function computes the randomized SVD of a data matrix using the random
projection scheme. The data matrix \code{A} is first compressed to a
smaller matrix with its columns (rows) being the linear combinations of the
columns (rows) of \code{A}. The classical SVD is then performed on the smaller
matrix. The randomized SVD of \code{A} are obtained by postprocessing.
}
\examples{

library(Matrix)
n <- 100
rank <- 2
clustertrue.y <- rep(1:rank, each = n/rank)
clustertrue.z <- rep(1:rank, each = n/rank)
A <- matrix(0, n, n)
for(i in 1:n) {
     for(j in 1:n) {
        A[i, j] <- ifelse(clustertrue.y[i] == clustertrue.z[i], rbinom(1, 1, 0.2), rbinom(1, 1, 0.1))
    }
}
diag(A) <- 0
A <- as(A, "dgCMatrix")
rsvd.pro(A, rank)

}
\references{
N. Halko, P.-G. Martinsson, and J. A. Tropp. (2011)
\emph{Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions},
\emph{SIAM review, Vol. 53(2), 217-288}\cr
\url{https://epubs.siam.org/doi/10.1137/090771806}\cr
}
